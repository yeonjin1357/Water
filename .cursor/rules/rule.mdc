---
description:
globs:
alwaysApply: true
---

# 물 마시기 리마인더 앱 프로젝트

## 프로젝트 개요

극도로 심플한 물 마시기 리마인더 앱 개발

## 기술 스택

- **Flutter** (Dart)
- 크로스 플랫폼 지원 (iOS/Android)
- 로컬 데이터 저장

## 차별화 전략: 극도의 미니멀리즘

기존 앱들이 너무 복잡한 점을 파고들어 "물 마시기에만 집중"하는 앱

### 핵심 원칙

- **딱 3개 화면**: 메인(물 추가), 설정, 통계
- 탭 한 번으로 250ml 추가
- 롱탭으로 커스텀 양 입력
- 불필요한 기능 제거 (칼로리, 카페인, 다이어트 연동 등)

## 주요 기능

1. **물 섭취 기록**
   - 원탭으로 빠른 기록
   - 일일 목표량 설정
2. **리마인더**
   - 주기적 알림
   - 시간대별 커스터마이징
3. **간단한 통계**
   - 일/주/월 통계
   - 목표 달성률

## 개발 방침

- 복잡한 기능보다 핵심 기능의 완성도에 집중
- 광고 없는 완전 무료 앱
- 직관적이고 깔끔한 UI/UX

## 경쟁 앱 분석

- 기존 앱들은 기능이 너무 많아 복잡함
- 단순히 물 마시기 습관만 기록하고 싶은 사용자층 존재
- 미니멀한 접근으로 차별화 가능

## 디자인 시스템

### 디자인 컨셉: "물방울 미니멀리즘"

물방울 하나에 모든 인터랙션을 집중시키는 극도로 심플한 디자인

### 색상 팔레트

- **Primary**: #2196F3 (밝은 하늘색)
- **Secondary**: #1976D2 (진한 블루)
- **Background**: #F5F9FF (아주 연한 블루-화이트)
- **Dark Mode Base**: #0D47A1 (네이비 블루)

### 디자인 원칙

1. **물방울 모티브**

   - 메인 버튼: 큰 물방울 형태
   - 애니메이션: 탭할 때 물결 퍼지는 효과
   - 진행 표시: 컵이 차오르는 비주얼

2. **타이포그래피**

   - 숫자: 굵고 큰 폰트 (목표량/현재량 강조)
   - 텍스트: 최소화, 아이콘으로 대체

3. **공백의 미학**

   - 화면의 60%는 여백
   - 플로팅 액션 버튼 스타일
   - 카드 UI 지양, 직접적인 요소 배치

4. **다크모드**
   - 네이비 블루 베이스
   - 물방울은 여전히 밝게 유지
   - 자동 전환 지원

## 데이터 모델

### WaterIntake

- id: String
- amount: int (ml 단위)
- timestamp: DateTime
- note: String? (선택적 메모)

### UserSettings

- dailyGoal: int (기본 2000ml)
- reminderInterval: int (분 단위)
- reminderStartTime: TimeOfDay
- reminderEndTime: TimeOfDay
- defaultAmount: int (기본 250ml)
- isDarkMode: bool
- language: String (기본 'ko')

## 프로젝트 구조

```
lib/
├── models/       # 데이터 모델 클래스
├── screens/      # 화면 (main, settings, stats)
├── widgets/      # 재사용 가능한 컴포넌트
├── services/     # 로컬 저장소, 알림 서비스
├── utils/        # 헬퍼 함수, 날짜 처리 등
└── constants/    # 색상, 텍스트 상수, 테마
```

## 상태 관리

- **Provider 패턴** 사용 (복잡성 최소화)
- **전역 상태**: 일일 섭취량, 사용자 설정, 물 섭취 기록
- **로컬 상태**: UI 애니메이션, 임시 입력값, 폼 검증

## 데이터 저장

- **SharedPreferences**: 설정값, 간단한 사용자 선호도
- **SQLite (sqflite)**: 물 섭취 기록, 통계 데이터
- **백업**: 로컬 JSON 파일로 내보내기/가져오기 기능

## 성능 및 배터리 최적화

- 백그라운드 작업 최소화
- 알림은 시스템 스케줄러 활용 (flutter_local_notifications)
- 애니메이션은 60fps 유지하되 필요시에만 실행
- 메모리 누수 방지를 위한 dispose() 철저히 구현

## Dart 코딩 규칙

### 명명 규칙

- **클래스명**: PascalCase (예: `WaterIntake`)
- **파일명**: snake_case (예: `water_intake.dart`)
- **변수/함수**: camelCase (예: `dailyGoal`, `calculateProgress()`)
- **상수**: lowerCamelCase 또는 SCREAMING_SNAKE_CASE (예: `defaultAmount` 또는 `MAX_WATER_AMOUNT`)
- **Private 멤버**: 언더스코어로 시작 (예: `_privateMethod()`)

### 필수 준수 사항

```dart
// ✅ 좋은 예시
class WaterIntakeService {
  final DatabaseHelper _dbHelper;
  late final StreamController<int> _intakeController;

  // null safety 항상 고려
  Future<int?> getTodayIntake() async {
    try {
      final result = await _dbHelper.query();
      return result?.amount;
    } catch (e) {
      debugPrint('Error: $e');
      return null;
    }
  }

  // dispose 메서드 구현
  void dispose() {
    _intakeController.close();
  }
}

// ❌ 피해야 할 예시
class water_intake {  // 잘못된 명명
  var dbHelper;  // 타입 미지정

  getTodayIntake() {  // 반환 타입 미지정
    // try-catch 없음
    return dbHelper.query();
  }
  // dispose 없음
}
```

### 주요 체크리스트

1. **Null Safety**: 모든 변수에 null 가능성 명시 (`?`, `!`, `late`)
2. **타입 명시**: `var` 대신 명확한 타입 사용
3. **에러 처리**: try-catch 블록으로 예외 처리
4. **비동기 처리**: async/await 올바른 사용
5. **메모리 관리**: StreamController, AnimationController 등은 반드시 dispose
6. **const 활용**: 가능한 곳에서 const 생성자 사용
7. **주석**: 복잡한 로직에만 간단한 주석 추가

### 자주 하는 실수 방지

```dart
// setState 중복 호출 방지
if (mounted) {
  setState(() {
    // UI 업데이트
  });
}

// BuildContext 잘못된 사용 방지
// ❌ 비동기 후 context 사용
await someAsyncWork();
Navigator.push(context, ...);  // 위험!

// ✅ 올바른 사용
await someAsyncWork();
if (context.mounted) {
  Navigator.push(context, ...);
}

// List 초기화
// ❌
List<String> items = [];  // growable list

// ✅ 불변 리스트가 필요한 경우
const List<String> items = [];
// 또는
final List<String> items = List.unmodifiable([]);
```
